<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://yoosen.github.io/blog/blog/interview/network.html"><meta property="og:site_name" content="Yoosen"><meta property="og:title" content="计算机网络"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-09-07T03:26:35.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:published_time" content="2022-06-06T00:00:00.000Z"><meta property="article:modified_time" content="2022-09-07T03:26:35.000Z"><script src="https://kit.fontawesome.com/ca37c296c5.js" crossorigin="anonymous"></script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3443684_7gukxs1ccvv.css"><title>计算机网络 | Yoosen</title><meta name="description" content="Yoosen's blog">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/blog/assets/style.1da8863c.css">
    <link rel="modulepreload" href="/blog/assets/app.67ff9014.js"><link rel="modulepreload" href="/blog/assets/network.html.6aced1da.js"><link rel="modulepreload" href="/blog/assets/network.html.06faec9a.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/blog/" class="home-link"><img class="logo" src="/blog/avatar.png" alt="Yoosen"><!----><span class="site-name hide-in-pad">Yoosen</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/blog/" class="nav-link" arialabel="主页"><i class="icon iconfont icon-shouye"></i>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/guide/" class="nav-link" arialabel="使用指南"><i class="icon iconfont icon-guide"></i>使用指南<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="笔记"><span class="title"><i class="icon iconfont icon-biji"></i>笔记</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/blog/cpp/C++Tutorial.html" class="nav-link" arialabel="C++ Tutorial"><i class="icon iconfont icon-cpp"></i>C++ Tutorial<!----></a></li><li class="dropdown-item"><a href="/blog/cpp/Vector.html" class="nav-link" arialabel="Vector"><i class="icon iconfont icon-bolt"></i>Vector<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/blog/algorithm/" class="nav-link" arialabel="算法"><i class="icon iconfont icon-suanfabaoguanli"></i>算法<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="面试"><span class="title"><i class="icon iconfont icon-tanhuamianshi"></i>面试</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/blog/interview/question.html" class="nav-link" arialabel="面试"><i class="icon iconfont icon-mianshianpai"></i>面试<!----></a></li><li class="dropdown-item"><a href="/blog/interview/MySQL.html" class="nav-link" arialabel="MySQL"><i class="icon iconfont icon-mysql"></i>MySQL<!----></a></li><li class="dropdown-item"><a href="/blog/interview/os.html" class="nav-link" arialabel="操作系统"><i class="icon iconfont icon-caozuoxitong"></i>操作系统<!----></a></li><li class="dropdown-item"><a aria-current="page" href="/blog/interview/network.html" class="router-link-active router-link-exact-active nav-link active" arialabel="计算机网络"><i class="icon iconfont icon-networks"></i>计算机网络<!----></a></li></ul></button></div></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/Yoosen" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/blog/" class="nav-link sidebar-link sidebar-page" arialabel="主页"><i class="icon iconfont icon-home"></i>主页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-cpp"></i><span class="title">C++ Tutorial</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/cpp/C++Tutorial.html" class="nav-link sidebar-link sidebar-page" arialabel="C++笔记"><i class="icon iconfont icon-biji"></i>C++笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/cpp/Vector.html" class="nav-link sidebar-link sidebar-page" arialabel="Vector"><i class="icon iconfont icon-vector"></i>Vector<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-suanfabaoguanli"></i><span class="title">算法</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/algorithm/" class="nav-link sidebar-link sidebar-page" arialabel="算法笔记"><i class="icon iconfont icon-suanfabaoguanli"></i>算法笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><i class="icon iconfont icon-tanhuamianshi"></i><span class="title">面试</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/interview/question.html" class="nav-link sidebar-link sidebar-page" arialabel="我的面试"><i class="icon iconfont icon-mianshianpai"></i>我的面试<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/interview/MySQL.html" class="nav-link sidebar-link sidebar-page" arialabel="MySQL"><i class="icon iconfont icon-mysql"></i>MySQL<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/interview/os.html" class="nav-link sidebar-link sidebar-page" arialabel="操作系统"><i class="icon iconfont icon-caozuoxitong"></i>操作系统<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/blog/interview/network.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" arialabel="计算机网络"><i class="icon iconfont icon-networks"></i>计算机网络<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#tcp" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="TCP"><!---->TCP<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-0-tcp的特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.0 TCP的特点"><!---->1.0 TCP的特点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-1-tcp的粘包和拆包" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.1 TCP的粘包和拆包"><!---->1.1 TCP的粘包和拆包<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-2-为什么会产生粘包和拆包呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.2 为什么会产生粘包和拆包呢?"><!---->1.2 为什么会产生粘包和拆包呢?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-3三次握手是为了什么" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.3三次握手是为了什么？"><!---->1.3三次握手是为了什么？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-4-三次握手中-第二次握手的时候为什么还要传回syn" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.4 三次握手中，第二次握手的时候为什么还要传回SYN？"><!---->1.4 三次握手中，第二次握手的时候为什么还要传回SYN？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-5-为什么要三次握手-4次握手可以吗" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.5 为什么要三次握手，4次握手可以吗"><!---->1.5 为什么要三次握手，4次握手可以吗<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-6-websocket" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.6 websocket"><!---->1.6 websocket<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-7-四次挥手" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.7 四次挥手"><!---->1.7 四次挥手<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-8-为什么建立连接是三次握手-关闭连接确是四次挥手呢" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.8 为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><!---->1.8 为什么建立连接是三次握手，关闭连接确是四次挥手呢？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-9-如果已经建立了连接-但是客户端突然出现故障了怎么办" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.9 如果已经建立了连接，但是客户端突然出现故障了怎么办？"><!---->1.9 如果已经建立了连接，但是客户端突然出现故障了怎么办？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#udp" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="UDP"><!---->UDP<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-10-udp的特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.10 UDP的特点"><!---->1.10 UDP的特点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-11-tcp和-udp的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.11 TCP和 UDP的区别"><!---->1.11 TCP和 UDP的区别<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_1-12-udp的应用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="1.12 UDP的应用场景"><!---->1.12 UDP的应用场景<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_2-0-http-状态码" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.0 HTTP 状态码"><!---->2.0 HTTP 状态码<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_2-1-http长连接和短链接" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.1 HTTP长连接和短链接"><!---->2.1 HTTP长连接和短链接<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_2-2-get-和-post-请求方式对比" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.2 GET 和 POST 请求方式对比"><!---->2.2 GET 和 POST 请求方式对比<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_2-3-http-1-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.3 HTTP 1.1"><!---->2.3 HTTP 1.1<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#http-2-0" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="HTTP 2.0"><!---->HTTP 2.0<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_2-4-http3-0-quic和之前的不同" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.4 http3.0 QUIC和之前的不同"><!---->2.4 http3.0 QUIC和之前的不同<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_2-5-http的缺点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.5 HTTP的缺点"><!---->2.5 HTTP的缺点<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_2-6-http请求过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.6 HTTP请求过程"><!---->2.6 HTTP请求过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_2-7-聊聊https" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="2.7 聊聊HTTPS"><!---->2.7 聊聊HTTPS<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_3-0-通过ip发送请求的过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.0 通过IP发送请求的过程"><!---->3.0 通过IP发送请求的过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_3-1-有了ip地址-为什么还要用mac地址" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="3.1 有了IP地址，为什么还要用MAC地址？"><!---->3.1 有了IP地址，为什么还要用MAC地址？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_4-0-什么是xss攻击" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.0 什么是XSS攻击"><!---->4.0 什么是XSS攻击<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_4-1-如何解决xss攻击" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.1 如何解决xss攻击"><!---->4.1 如何解决xss攻击<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_4-2-半连接队列和-syn-flood-攻击的关系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.2 半连接队列和 SYN Flood 攻击的关系"><!---->4.2 半连接队列和 SYN Flood 攻击的关系<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/interview/network.html#_4-3-socket的执行过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="4.3 socket的执行过程"><!---->4.3 socket的执行过程<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><a href="/blog/slide.html" class="nav-link sidebar-link sidebar-page" arialabel="幻灯片页"><i class="icon iconfont icon-slides"></i>幻灯片页<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><i class="icon iconfont icon-networks"></i>计算机网络</h1><div class="page-info"><span class="date-info" arialabel="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年6月6日</span><meta property="datePublished" content="2022-06-06T00:00:00.000Z"></span><span class="category-info" arialabel="分类🌈" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" arialabelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category category2 clickable" role="navigation">面试</li><meta property="articleSection" content="面试"></ul></span><!----><span class="reading-time-info" arialabel="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" arialabelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 32 分钟</span><meta property="timeRequired" content="PT32M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#tcp" class="router-link-active router-link-exact-active toc-link level2">TCP</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-0-tcp的特点" class="router-link-active router-link-exact-active toc-link level2">1.0 TCP的特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-1-tcp的粘包和拆包" class="router-link-active router-link-exact-active toc-link level2">1.1 TCP的粘包和拆包</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-2-为什么会产生粘包和拆包呢" class="router-link-active router-link-exact-active toc-link level2">1.2 为什么会产生粘包和拆包呢?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-3三次握手是为了什么" class="router-link-active router-link-exact-active toc-link level2">1.3三次握手是为了什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-4-三次握手中-第二次握手的时候为什么还要传回syn" class="router-link-active router-link-exact-active toc-link level2">1.4 三次握手中，第二次握手的时候为什么还要传回SYN？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-5-为什么要三次握手-4次握手可以吗" class="router-link-active router-link-exact-active toc-link level2">1.5 为什么要三次握手，4次握手可以吗</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-6-websocket" class="router-link-active router-link-exact-active toc-link level2">1.6 websocket</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-7-四次挥手" class="router-link-active router-link-exact-active toc-link level2">1.7 四次挥手</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-8-为什么建立连接是三次握手-关闭连接确是四次挥手呢" class="router-link-active router-link-exact-active toc-link level2">1.8 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-9-如果已经建立了连接-但是客户端突然出现故障了怎么办" class="router-link-active router-link-exact-active toc-link level2">1.9 如果已经建立了连接，但是客户端突然出现故障了怎么办？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#udp" class="router-link-active router-link-exact-active toc-link level2">UDP</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-10-udp的特点" class="router-link-active router-link-exact-active toc-link level2">1.10 UDP的特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-11-tcp和-udp的区别" class="router-link-active router-link-exact-active toc-link level2">1.11 TCP和 UDP的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_1-12-udp的应用场景" class="router-link-active router-link-exact-active toc-link level2">1.12 UDP的应用场景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_2-0-http-状态码" class="router-link-active router-link-exact-active toc-link level2">2.0 HTTP 状态码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_2-1-http长连接和短链接" class="router-link-active router-link-exact-active toc-link level2">2.1 HTTP长连接和短链接</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_2-2-get-和-post-请求方式对比" class="router-link-active router-link-exact-active toc-link level2">2.2 GET 和 POST 请求方式对比</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_2-3-http-1-1" class="router-link-active router-link-exact-active toc-link level2">2.3 HTTP 1.1</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#http-2-0" class="router-link-active router-link-exact-active toc-link level2">HTTP 2.0</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_2-4-http3-0-quic和之前的不同" class="router-link-active router-link-exact-active toc-link level2">2.4 http3.0 QUIC和之前的不同</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_2-5-http的缺点" class="router-link-active router-link-exact-active toc-link level2">2.5 HTTP的缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_2-6-http请求过程" class="router-link-active router-link-exact-active toc-link level2">2.6 HTTP请求过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_2-7-聊聊https" class="router-link-active router-link-exact-active toc-link level2">2.7 聊聊HTTPS</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_3-0-通过ip发送请求的过程" class="router-link-active router-link-exact-active toc-link level2">3.0 通过IP发送请求的过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_3-1-有了ip地址-为什么还要用mac地址" class="router-link-active router-link-exact-active toc-link level2">3.1 有了IP地址，为什么还要用MAC地址？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_4-0-什么是xss攻击" class="router-link-active router-link-exact-active toc-link level2">4.0 什么是XSS攻击</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_4-1-如何解决xss攻击" class="router-link-active router-link-exact-active toc-link level2">4.1 如何解决xss攻击</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_4-2-半连接队列和-syn-flood-攻击的关系" class="router-link-active router-link-exact-active toc-link level2">4.2 半连接队列和 SYN Flood 攻击的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/interview/network.html#_4-3-socket的执行过程" class="router-link-active router-link-exact-active toc-link level2">4.3 socket的执行过程</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h1 id="_1-传输层" tabindex="-1"><a class="header-anchor" href="#_1-传输层" aria-hidden="true">#</a> 1.传输层</h1><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><h2 id="_1-0-tcp的特点" tabindex="-1"><a class="header-anchor" href="#_1-0-tcp的特点" aria-hidden="true">#</a> 1.0 TCP的特点</h2><p>提供可靠传输，实行顺序控制或重发控制机制。具有流控制、拥塞控制、提高网络利用率等众多功能。</p><p>充分实现了数据传输时各种控制功能，可以进行丢包时的重发机制，还可以对次序乱掉的分包进行顺序控制。</p><p>TCP 的特点及其目的</p><p>TCP 通过<code>检验和</code>、<code>连接管理</code>、<code>确认应答</code> 、 <code>重发超时机制</code>、<code>序列号机制</code>、<code>以段为单位发送数据</code>、<code>窗口控制</code>、<code>流控制</code>、等机制进行可靠传输。</p><p><code>检验和</code>：这个原理和 MD5 完整性校验一致，目检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p><p><code>连接管理</code>：采用三次握手的方式建立可靠的通信传输，</p><p><code>确认应答</code> : 确认应答就是会发送一条已经收到段的应答消息。</p><p><code>重发超时机制</code>：这个含义在上面的序列号机制已经提到，当发送端长时间没有接收到，确认信息时，则会对该条报文进行确认，因为此时他认为，是报文发送失败。所以这个超时时间的设定就显得尤为重要。TCP采用了一个很巧妙的方法，那就是<code>每次发包时都会，计算往返时间及其偏差，重传的时间就是比两者之和稍大一点的值。</code></p><p><code>RTT：往返时间</code></p><p><code>RTO：重发时间</code>，重发时间略大于多次RTT的平均值</p><p><code>序列号机制</code>：当发送的数据到达接收主机时，接收端主机会返回已经收到的ACK确认号，确认应答。但是确认应答有可能出现以下这种情况，<code>报文发送时丢失，确认应答信息丢失</code>。这样就可能会导致发送端一直重发报文。一般情况下，就发送端会等待一段时间后，如果没有收到确认应答，则会进行重发，但是我们也会遇到这种情况，当我们因为网络延迟之后，在我们发送方重传了报文之后，才接收到确认应答的信息，所以这样接收端就会收到无休止的重复包，所以这时候我们需要引入序列号机制，就是给每一个TCP报文添加一个序列号，告知发送方，我收到了哪条信息，下次传输时应该传输哪个报文。</p><p><code>以MSS为单位发送数据</code>：建立TCP连接的同时，也可以确定发送数据包的单位，我们称其为最大发送长度MSS，该值是在三次握手时计算得出的，<code>会在两者之间选择一个都可接受的最小值</code>，TCP在发送数据时，重发时是以MSS为单位进行发送的。</p><p><code>流量控制，利用窗口控制提高速度</code>：上面我们提到的，每次都要进行确认，如果往返时间较长，这会大大降低效率，所以TCP引入了窗口的概念，这样我们就可以使确认的不是每个分段，而是以最大的单位进行确认，就是发完一个段之后，不用等到确认信息，继续发段。<code>窗口大小就是无需等待确认应答， 而可以发送数据的最大值</code>。当然这种情况也会出现丢失段的情况，因为TCP有序列号机制，所以知道哪些段需要重发，发送方的缓冲区，会将待重发的段保存到缓冲区内，知道收到确认应答。</p><p><code>流控制</code>：可以让发送端根据接收端的接收实力进行发送。接收端会向发送端发送可以接收的数据大小。另外为了防止接收不到窗口更新通知，发送端则会时不时发送一个窗口探测的数据来获取窗口信息。</p><p><code>拥塞控制</code>：</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。<code>发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个</code>。 TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong> 。 <strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍 2，4，8，16。指数型增长</p><p>当然慢开始的cwnd的大小不是无限制增长的，当小于 ssthresh 时，使用慢启动算法，大于等于时则启动拥塞避免算法。 <strong>拥塞避免</strong> <strong>：</strong> 那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong> 此时则变成了线性增长。</p><p>当报文</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了【拥塞发生算法】</p><p><code>拥塞发生</code>：</p><p>此时则采用两种方法解决丢包问题</p><p><code>超时重传：</code>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><p><code>ssthresh</code> 设为 <code>cwnd/2</code>，</p></li><li><p><code>cwnd</code> 重置为 <code>1</code></p></li></ul><p>然后就重新慢启动，这大起大落不太行。</p><p><code>快速重传：</code></p><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p><p><code>cwnd = cwnd/2 </code>，也就是设置为原来的一半; <code>ssthresh = cwnd;</code> 进入快速恢复算法</p><p>8.4 快速恢复 快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p><p><code>cwnd = cwnd/2 ，也就是设置为原来的一半;&lt;br /&gt;ssthresh = cwnd;</code></p><p>然后，进入快速恢复算法如下：</p><p>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； 重传丢失的数据包； 如果再收到重复的 ACK，那么 cwnd 增加 1；</p><p>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</p><p><img src="/blog/interview-img/image-20211009134917386.png" alt="拥塞控制" loading="lazy"></p><p>具体细节大家可以看下这两篇文章</p><p>推荐阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/133307545" target="_blank" rel="noopener noreferrer">30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制发愁<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_1-1-tcp的粘包和拆包" tabindex="-1"><a class="header-anchor" href="#_1-1-tcp的粘包和拆包" aria-hidden="true">#</a> 1.1 TCP的粘包和拆包</h2><p>TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一<strong>个完整的包可能会被TCP拆分成多个包进行发送</strong> ，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong> ，这就是所谓的TCP粘包和拆包问题。</p><h2 id="_1-2-为什么会产生粘包和拆包呢" tabindex="-1"><a class="header-anchor" href="#_1-2-为什么会产生粘包和拆包呢" aria-hidden="true">#</a> 1.2 为什么会产生粘包和拆包呢?</h2><p><code>要发送的数据小于TCP发送缓冲区的大小</code>，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；<code>要发送的数据大于TCP发送缓冲区剩余空间大小，</code>将会发生拆包；待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度&gt;MSS。解决方案：发送端将每个数据包封装为固定长度在数据尾部增加特殊字符进行分割将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</p><p>MTU：一个网络包的最大长度</p><p>MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</p><p><img src="/blog/network-img/image-20211007102650386.png" alt="TCP头部" loading="lazy"></p><p>推荐阅读：<a href="https://www.cnblogs.com/yaochunhui/p/14175396.html" target="_blank" rel="noopener noreferrer">TCP粘包/拆包的产生原因和解决办法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h1 id="握手" tabindex="-1"><a class="header-anchor" href="#握手" aria-hidden="true">#</a> 握手</h1><h2 id="_1-3三次握手是为了什么" tabindex="-1"><a class="header-anchor" href="#_1-3三次握手是为了什么" aria-hidden="true">#</a> 1.3<strong>三次握手是为了什么？</strong></h2><p>三次握手链接的本质是，所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</p><p>推荐阅读：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener noreferrer">两张动图-彻底明白TCP的三次握手与四次挥手<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>三次握手是为了，保证可靠传输，我们假设客户端向A发送消息，首先告诉他，我要给你发消息啦，然后客户端给他发送，我收到你的消息啦，也就是Ack/syn。此条数据代表的含义为，我收到你的消息，同时我也准备好了，但是此时接受端，并不知道对方有没有收到消息，所以发送端，在收到接收端的ack和syn包之后，也要发送一个 ack 确认。这样双方则建立了链接。</p><p><strong>三次握手过程</strong></p><p>发送端：我发送syn（同步序列编号）的数据包给你啦。</p><p>接收端：我已经收到你的数据包啦，我将syn/ack编号发送给你啦</p><p>发送端：明白，我同时将ack的包发送给你啦。</p><p><img src="/blog/network-img/image-20211007105918285.png" alt="三次握手" loading="lazy">握手情况如下</p><p><img src="/blog/network-img/image-20211007110054621.png" alt="抓包情况" loading="lazy"></p><p>大家注意，这里三次握手时，客户端和服务端的状态也需要记忆，也是面试时的高频考点。</p><h2 id="_1-4-三次握手中-第二次握手的时候为什么还要传回syn" tabindex="-1"><a class="header-anchor" href="#_1-4-三次握手中-第二次握手的时候为什么还要传回syn" aria-hidden="true">#</a> 1.4 三次握手中，第二次握手的时候为什么还要传回SYN？</h2><p>而回传SYN则是为了建立并确认从服务端到客户端的通信。是为了告诉发送端，我也准备好了。</p><h2 id="_1-5-为什么要三次握手-4次握手可以吗" tabindex="-1"><a class="header-anchor" href="#_1-5-为什么要三次握手-4次握手可以吗" aria-hidden="true">#</a> 1.5 为什么要三次握手，4次握手可以吗</h2><ul><li><p>三次握手才可以<code>阻止重复历史连接</code>的初始化（主要原因）</p></li><li><p>三次握手才可以同步双方的初始序列号</p></li><li><p>三次握手才可以避免资源浪费</p></li></ul><p><code>重复连接问题</code></p><p>因为网络会堵塞，所以有可能因为网络堵塞，第一个客户端发出第一个SYN = 10包之后，迟迟收不到SYN/ACK，所以就进行补发 SYN = 20，此时服务端收到了 SYN = 10 的旧包，然后发送ACK和SYN，但是呢？此时客户端发现我应该接收的是 SYN = 20 的ACK，而不是历史的连接，所以就会发送RST拒绝连接，等SYN= 20的 ACK来了之后，再进行连接。三次握手可以让客户端通过上下文来进行判断。</p><p><code>同步双方的初始序列号</code></p><p>序列号同步是可靠传输的基础，通过三次握手可以保证双方的序列号同步，其实四次握手也可以，只不过第二次握手把两个包合成一个了。</p><p><code>避免资源浪费</code></p><p>防止历史连接的建立，如果使用两次握手的话，现在已经连接成功，但是之前因为网络问题延迟传输的报文，再一次发到服务器则有可能再次造成连接。</p><p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p><p>不使用「两次握手」和「四次握手」的原因：</p><p>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号； 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p><p>推荐阅读：<a href="https://segmentfault.com/a/1190000022271536" target="_blank" rel="noopener noreferrer">硬不硬你说了算！35 张图解被问千百遍的 TCP 三次握手和四次挥手面试题<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_1-6-websocket" tabindex="-1"><a class="header-anchor" href="#_1-6-websocket" aria-hidden="true">#</a> 1.6 websocket</h2><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><p>推荐阅读：<a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener noreferrer">WebSocket 教程<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p id="四次挥手"></p><h1 id="挥手" tabindex="-1"><a class="header-anchor" href="#挥手" aria-hidden="true">#</a> 挥手</h1><h2 id="_1-7-四次挥手" tabindex="-1"><a class="header-anchor" href="#_1-7-四次挥手" aria-hidden="true">#</a> 1.7 四次挥手</h2><p><img src="/blog/interview-img/image-20211009142428953.png" alt="四次挥手" loading="lazy"></p><p>A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><h2 id="_1-8-为什么建立连接是三次握手-关闭连接确是四次挥手呢" tabindex="-1"><a class="header-anchor" href="#_1-8-为什么建立连接是三次握手-关闭连接确是四次挥手呢" aria-hidden="true">#</a> 1.8 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h2><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次.</p><h2 id="_1-9-如果已经建立了连接-但是客户端突然出现故障了怎么办" tabindex="-1"><a class="header-anchor" href="#_1-9-如果已经建立了连接-但是客户端突然出现故障了怎么办" aria-hidden="true">#</a> 1.9 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP设有一个活计时器，如果客户端没有发送请求，一直等待的话，则会白白浪费服务端请求，服务端每收到请求一次则会将活计时器重置，时间通常是设置为2小时，若2小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/398890723" target="_blank" rel="noopener noreferrer">TCP 才不傻：三次握手和四次挥手的异常处理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="udp" tabindex="-1"><a class="header-anchor" href="#udp" aria-hidden="true">#</a> UDP</h2><h2 id="_1-10-udp的特点" tabindex="-1"><a class="header-anchor" href="#_1-10-udp的特点" aria-hidden="true">#</a> 1.10 UDP的特点</h2><h2 id="_1-11-tcp和-udp的区别" tabindex="-1"><a class="header-anchor" href="#_1-11-tcp和-udp的区别" aria-hidden="true">#</a> 1.11 TCP和 UDP的区别</h2><p><img src="/blog/interview-img/image-20211009150136763.png" alt="" loading="lazy"></p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><p>推荐阅读：<a href="https://www.cnblogs.com/williamjie/p/9390164.html" target="_blank" rel="noopener noreferrer">TCP和UDP的最完整的区别 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_1-12-udp的应用场景" tabindex="-1"><a class="header-anchor" href="#_1-12-udp的应用场景" aria-hidden="true">#</a> 1.12 UDP的应用场景</h2><p>广播：因为其可以一对多进行发送，所以可用于广播</p><p>实时游戏：因为TCP如果丢包，则会等待这个包进行重发，这样就会卡住，有可能出现，恢复后，人已经死了的情况。</p><p>网页或者app的访问，QUIC</p><p>音视频</p><h1 id="_2-应用层" tabindex="-1"><a class="header-anchor" href="#_2-应用层" aria-hidden="true">#</a> 2.应用层</h1><h1 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h1><p id="状态码"></p><h2 id="_2-0-http-状态码" tabindex="-1"><a class="header-anchor" href="#_2-0-http-状态码" aria-hidden="true">#</a> 2.0 HTTP 状态码</h2><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td>服务端无法处理请求</td></tr><tr><td>5XX</td><td>服务端错误状态码</td><td>服务端处理请求出错</td></tr></tbody></table><p>301：永久重定向</p><p>302：临时重定向</p><p>400：语法错误</p><p>401：表示需要认证</p><p>403：表示请求被拒绝</p><p>404：没发现资源</p><p>500：服务器内部出现故障</p><p>503：服务器正在维护，或者已经超载</p><p>推荐阅读：<a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener noreferrer">HTTP 状态码<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_2-1-http长连接和短链接" tabindex="-1"><a class="header-anchor" href="#_2-1-http长连接和短链接" aria-hidden="true">#</a> 2.1 HTTP长连接和短链接</h2><p>短链接：每进行一次HTTP通信，就要断开一次TCP连接</p><p>持久连接：建立一次TCP连接后进行多次请求和响应的交互。</p><div class="language-http ext-http line-numbers-mode"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span><span class="token header-value">keep-alive</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>推荐阅读：<a href="https://www.cnblogs.com/cswuyg/p/3653263.html" target="_blank" rel="noopener noreferrer">HTTP的长连接和短连接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_2-2-get-和-post-请求方式对比" tabindex="-1"><a class="header-anchor" href="#_2-2-get-和-post-请求方式对比" aria-hidden="true">#</a> 2.2 GET 和 POST 请求方式对比</h2><p>Http 常用的请求方法共有 8种，</p><ol><li>在HTTP1.0中，定义了三种请求方法：<code>GET, POST 和 HEAD</code>方法。</li><li>在HTTP1.1中，新增了五种请求方法：<code>OPTIONS, PUT, DELETE, TRACE 和 CONNECT</code>方法 但我们常用的一般就是<code>GET和POST</code>请求。</li></ol><p>我们常用的主要有两种。</p><p>GET，POST他们两个的不同</p><ul><li><p>GET有长度限制</p></li><li><p>POST 比GET安全，因为 url GET是直接暴露的。POST数据不会显示在URL中,是放在Request body中。</p></li><li><p>参数类型，GET只支持ASCLL码，POST没有要求。</p></li><li><p>GET请求会保存在浏览器记录里，POST浏览器也不会保存。</p></li><li><p>GET只支持url 编码，POST 则没有限制</p></li><li><p>GET会被浏览器主动缓存，POST则不会</p></li><li><p>GET回退是无害的，POST则是再次发出请求。</p></li></ul><p>GET有没有Request Body 呢？</p><p>因为 GET是直接暴露在外面的，但是浏览器对url的大小限制为 2K，所以如果长度太大，也就是 url 参数较多，则有可能不被接收。</p><p>有人说POST 比 GET安全，这是因为 POST 在地址栏，url是看不到的其实在http 中，他们两个都是不安全的，因为 HTTP 是明文传输。</p><p>GET 和 POST 请求发送的数据包有什么不同？</p><p>GET是一个包将Header 和 body 同时发送过去，POST 是先发送head ，再发送body，分两个包发送。</p><p>就像是GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼<code>老铁，我等下要送一批货来，你们准备接收一下哈</code>，然后再回头把货送过去。</p><p>推荐阅读：<a href="https://www.zhihu.com/question/28586791/answer/1890418047" target="_blank" rel="noopener noreferrer">GET 和 POST 到底有什么区别？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_2-3-http-1-1" tabindex="-1"><a class="header-anchor" href="#_2-3-http-1-1" aria-hidden="true">#</a> 2.3 HTTP 1.1</h2><p><strong>HTTP1.0和HTTP1.1的一些区别</strong></p><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><p><strong>缓存处理</strong> <code>，</code>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></li><li><p><strong>带宽优化及网络连接的使用，错误通知的管理</strong> <code>，</code>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p><strong>长连接</strong> <code>，</code>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p></li><li><p><code>压缩报文</code></p></li><li><p><strong>Host头处理</strong> <code>，</code>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li></ol><h2 id="http-2-0" tabindex="-1"><a class="header-anchor" href="#http-2-0" aria-hidden="true">#</a> <strong>HTTP 2.0</strong></h2><p><code>二进制编码</code>：HTTP/2 厉害的地方在于将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析，这里一句话总结就是，将侦使用二进制格式传输。 <code>header压缩</code>：</p><p>HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 <strong>HPACK</strong> 算法，HPACK 算法主要包含三个组成部分：</p><ul><li><p>静态字典；</p></li><li><p>动态字典；</p></li><li><p>Huffman 编码（压缩算法）</p></li></ul><p>客户端和服务器两端都会建立和维护「<strong>字典</strong> 」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，<strong>可达到 50%~90% 的高压缩率</strong> 。静态表是保存在 http2框架里的。</p><p><code>多路复用分侦</code>（server push）：HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。将一个请求变成一个流，然后再将流拆分成侦，然后这些侦是可以混杂在一起进行发送。</p><p><code>服务端主动发送：</code>可以在用户请求 html 时，可以主动的推送 css 资源，一次请求，多次发送。</p><p>推荐阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/352626472" target="_blank" rel="noopener noreferrer">面试官：你知道 HTTP/1.1 该如何优化吗？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://zhuanlan.zhihu.com/p/359920955" target="_blank" rel="noopener noreferrer">别再用 HTTP/1 了，快换 HTTP/2 吧！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_2-4-http3-0-quic和之前的不同" tabindex="-1"><a class="header-anchor" href="#_2-4-http3-0-quic和之前的不同" aria-hidden="true">#</a> 2.4 http3.0 QUIC和之前的不同</h2><p>http多是基于 TCP 的传输，因为 HTTP 2.0 也是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行。虽然 HTTP 2.0 通过多个 stream，使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，然而这中间并没有关联的数据。一前一后，前面 stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞。</p><p><code>基于 UDP 自定义的类似 TCP 的连接：</code></p><p>一条 TCP 连接是由四元组标识的，分别是源 IP、源端口、目的 IP、目的端口。ip改变之后连接断开</p><p>QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接。</p><p><code>重发：</code></p><p>tcp的重发是有缺陷的，当我们如果一个包，由于网络堵塞，发送失败，进行重传之后，然后我们收到包之后，不知道应该如何计算往返时间，不利于我们拥塞控制。</p><p><img src="/blog/interview-img/image-20211009154917574.png" alt="" loading="lazy"></p><p>这里加入了，偏移量和id，重发之后加1即可。</p><p><code>多路复用：</code></p><p>有了自定义的连接和重传机制，我们就可以解决上面 HTTP 2.0 的多路复用问题。同 HTTP 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3 的一个 UDP 包，虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户。</p><p><code>流量控制技术</code></p><p>在 TCP 协议中，接收端的窗口的起始点是下一个要接收并且 ACK 的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为 TCP 的 ACK 机制是基于序列号的累计应答，一旦 ACK 了一个序列号，就说明前面的都到了，所以只要前面的没到，后面的到了也不能 ACK，就会导致后面的到了，也有可能超时重传，浪费带宽。</p><p>只要收到的，就进行确认，因为后面的到了，前面的肯定已经发送，所以我们可以移动窗口，等待确认前面的和重发即可。</p><p><img src="/blog/interview-img/image-20211009160608303.png" alt="image-20211009160608303" loading="lazy"></p><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/32553477" target="_blank" rel="noopener noreferrer">科普：QUIC协议原理分析<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_2-5-http的缺点" tabindex="-1"><a class="header-anchor" href="#_2-5-http的缺点" aria-hidden="true">#</a> 2.5 HTTP的缺点</h2><ul><li><p>明文传输</p></li><li><p>没有校验，有可能被篡改</p></li><li><p>没有验证通信方身份</p></li></ul><p>HTTPS采用混合加密机制，位于HTTP/TCP之间，主要为高层协议服务。</p><h2 id="_2-6-http请求过程" tabindex="-1"><a class="header-anchor" href="#_2-6-http请求过程" aria-hidden="true">#</a> 2.6 HTTP请求过程</h2><p><strong>在浏览器输入网址显示页面的过程</strong></p><p>1.查询浏览器缓存，如果有直接访问</p><p>2.查询本地host文件，查询本地缓存，或者使用cmd,使用ipconfig /displaydns 命令查询</p><p>3.向DNS服务器发送DNS请求，查询本地DNS服务器（此时用到的是递归查询），这其中用的是UDP的协议</p><p>4.本地域名服务器会向<code>根域名服务器发送一个请求</code>，如果根域名服务器也不存在该域名时，</p><p>5.本地域名会向顶级域名服务器的下一级DNS服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。（上诉的迭代方式是迭代查询）</p><p>6.此时我们已经知道了ip地址，及其默认的端口号，http默认的是80端口，https默认的是https端口</p><p>7.我们首先会尝试使用http建立socket连接，三次握手之后，开始传送数据，如果是http的话，那么则接收数据，如果不是http,是https则会返回 3开头的重定向，将端口号从 80 端口改成 443 端口，并四次挥手断开之前的连接。</p><p>8.再来一遍三次握手，此时还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的</p><p>9.沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。</p><p>10.连接完毕，开始传输数据</p><p>这里还有很多细节，比如通过ip地址和子网掩码判断是否在同一子网，报文每一跳的情况等。还有 DNS 解析时，递归查询和迭代查询使用哪个传输层协议等，答的尽量细一些。</p><p>推荐阅读：<a href="https://blog.csdn.net/ailunlee/article/details/90600174" target="_blank" rel="noopener noreferrer">HTTP请求的完全过程<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_2-7-聊聊https" tabindex="-1"><a class="header-anchor" href="#_2-7-聊聊https" aria-hidden="true">#</a> 2.7 聊聊HTTPS</h2><p>HTTPS 是以安全为目标的 HTTP 通道.</p><p>在HTTP的基础上通过传输加密和<a href="https://baike.baidu.com/item/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/5294713" target="_blank" rel="noopener noreferrer">身份认证<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入<a href="https://baike.baidu.com/item/SSL/320778" target="_blank" rel="noopener noreferrer">SSL<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。</p><p>HTTPS使用的是443端口，HTTP是80端口，HTTPS比HTTP多了四次握手的过程所以效率有所降低，大概只有HTTP的1/10。HTTPS则是为了来解决HTTP明文传输，没有检验，有可能被篡改，无法验证对方身份的情况。</p><p>HTTPS原理也会考察，而且是高频考点，大家可以看下下面这两个文章</p><p>推荐阅读：</p><p><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617/" target="_blank" rel="noopener noreferrer">HTTP和HTTPS协议，看一篇就够了<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://www.cnblogs.com/xiaolincoding/p/14274353.html" target="_blank" rel="noopener noreferrer">几幅图，拿下 HTTPS <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h1 id="_3-网络层" tabindex="-1"><a class="header-anchor" href="#_3-网络层" aria-hidden="true">#</a> 3.网络层</h1><h2 id="_3-0-通过ip发送请求的过程" tabindex="-1"><a class="header-anchor" href="#_3-0-通过ip发送请求的过程" aria-hidden="true">#</a> 3.0 通过IP发送请求的过程</h2><p>TCP 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址）。</p><p>将这两个信息放到 IP 头里面，交给 IP 层进行传输。IP 层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可；如果不在同一个局域网，就需要发送到网关，还要需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器。</p><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/344248878" target="_blank" rel="noopener noreferrer">图解 | 你管这破玩意叫网络？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_3-1-有了ip地址-为什么还要用mac地址" tabindex="-1"><a class="header-anchor" href="#_3-1-有了ip地址-为什么还要用mac地址" aria-hidden="true">#</a> 3.1 有了IP地址，为什么还要用MAC地址？</h2><p>简而言之，标识网络中的一台计算机，比较常用的就是<strong>IP地址和MAC地址</strong> ，但计算机的IP地址可由用户自行更改，管理起来就相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。</p><p>那只使用MAC地址不用IP地址行不行呢？不行的！因为最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。</p><p>那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。</p><p>IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。</p><p>推荐阅读： <a href="https://www.zhihu.com/question/21546408/answer/53576595" target="_blank" rel="noopener noreferrer">有了 IP 地址，为什么还要用 MAC 地址？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h1 id="_4-网络安全篇" tabindex="-1"><a class="header-anchor" href="#_4-网络安全篇" aria-hidden="true">#</a> 4.网络安全篇</h1><h2 id="_4-0-什么是xss攻击" tabindex="-1"><a class="header-anchor" href="#_4-0-什么是xss攻击" aria-hidden="true">#</a> 4.0 什么是XSS攻击</h2><p>它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。</p><p>XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。</p><p>其实我们常用的留言板就可以产生XSS攻击，我们知道留言板通常的任务就是把用户留言的内容展示出来。</p><p>正常情况下，用户的留言都是正常的语言文字，留言板显示的内容也就没毛病。然而这个时候如果有人不按套路出牌，在留言内容中丢进去一行</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span>“这是一个攻击”<span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>那么留言板界面的网页代码就会变成形如以下：</p><p>那么这个时候问题就来了，当浏览器解析到用户输入的代码那一行时会发生什么呢？答案很显然，浏览器并不知道这些代码改变了原本程序的意图，会照做弹出一个信息框。就像这样</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>留言板<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>”board”</span> 
        <span class="token attr-name">&lt;script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span>“这是一个攻击”<span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>     
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p id="解决XSS"></p><h2 id="_4-1-如何解决xss攻击" tabindex="-1"><a class="header-anchor" href="#_4-1-如何解决xss攻击" aria-hidden="true">#</a> 4.1 如何解决xss攻击</h2><p>1.不相信用户输入</p><p>2.限制输长度</p><p>3.html转义等</p><p>4.对跳转型链接进行特殊对待</p><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/26177815" target="_blank" rel="noopener noreferrer">浅谈XSS攻击的那些事（附常用绕过姿势）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_4-2-半连接队列和-syn-flood-攻击的关系" tabindex="-1"><a class="header-anchor" href="#_4-2-半连接队列和-syn-flood-攻击的关系" aria-hidden="true">#</a> 4.2 半连接队列和 SYN Flood 攻击的关系</h2><p>TCP进入三次握手前，服务端会从<strong>CLOSED</strong> 状态变为<strong>LISTEN</strong> 状态,同时在内部创建了两个队列：半连接队列（SYN队列）和全连接队列（ACCEPT队列）。</p><p>什么是<strong>半连接队列（SYN队列）</strong> 呢? 什么是<strong>全连接队列（ACCEPT队列）</strong> 呢？回忆下TCP三次握手的图：</p><p><img src="/blog/network-img/image-20211007105918285.png" alt="三次握手" loading="lazy"></p><ul><li><p>TCP三次握手时，客户端发送SYN到服务端，服务端收到之后，便回复<strong>ACK和SYN</strong> ，状态由<strong>LISTEN变为SYN_RCVD</strong> ，此时这个连接就被推入了<strong>SYN队列</strong> ，即半连接队列。</p></li><li><p>当客户端回复ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入ACCEPT队列，即全连接队列。</p></li></ul><p>SYN Flood是一种典型的DoS (Denial of Service，拒绝服务) 攻击，它在短时间内，伪造<strong>不存在的IP地址</strong> ,向服务器大量发起SYN报文。当服务器回复SYN+ACK报文后，不会收到ACK回应报文，导致服务器上建立大量的半连接半连接队列满了，这就无法处理正常的TCP请求啦。</p><p>主要有 <strong>syn cookie</strong> 和<strong>SYN Proxy防火墙</strong> 等方案应对。</p><ul><li><strong>syn cookie</strong> ：在收到SYN包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个cookie值作为自己的SYNACK包的序列号，回复SYN+ACK后，服务器并不立即分配资源进行处理，等收到发送方的ACK包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li><li><strong>SYN Proxy防火墙</strong> ：服务器防火墙会对收到的每一个SYN报文进行代理和回应，并保持半连接。等发送方将ACK包返回后，再重新构造SYN包发到服务器，建立真正的TCP连接。</li></ul><p>推荐阅读：<a href="https://blog.csdn.net/qq_41147507/article/details/109600713" target="_blank" rel="noopener noreferrer">半连接队列、全连接队列、SYN Flood 攻击、如何应对SYN Food攻击、半连接队列和 SYN Flood 攻击的关系<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_4-3-socket的执行过程" tabindex="-1"><a class="header-anchor" href="#_4-3-socket的执行过程" aria-hidden="true">#</a> 4.3 socket的执行过程</h2><p><img src="/blog/interview-img/image-20211009210759358.png" alt="" loading="lazy"></p><p>在connect位置进行三次握手</p><p>IO多路复用发生在accept函数之后</p><p>监听的是已经建立好连接准备发送数据的socket</p><p>说 TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。</p><p>除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>socket是一个文件，那么就有文件描述符</p><p><img src="/blog/interview-img/image-20211009205159787.png" alt="image-20211009205159787" loading="lazy"></p><p>该图片来自于《极客时间》</p><p>socket对应的文件不是存在磁盘中的，是存在内存中的，方便快速传输。</p><p>服务端一般是listen一个端口，然后理论上的最大连接数，则和客户端ip地址的数目和端口号的数目有关，则是 2^32 * 2^16次方。</p><p>但是现实中不能够连接那么多，因为socket文件是存储在内存中的，内存限制，而是文件描述符的个数也有所限制。</p><p>我们如何建立更多的socket 连接，我们可以通过fork子进程的方式，父进程用来</p><p>进程复制过程</p><p>该图片来自于《极客时间》</p><p>通过fork函数创建的子进程和父进程几乎是一模一样的，（文件描述符列表也复制了一份，这样子进程就能通过这个一模一样的文件描述符去操作父进程的已连接socket了。</p><p>epoll create</p><p>epoll controll：挂到红黑树上时，如何快速放到链表，当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还<code>会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。</code>所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了</p><p>epoll wait 查看链表</p><p>推荐阅读：<a href="https://www.zhihu.com/question/29637351" target="_blank" rel="noopener noreferrer">socket编程到底是什么？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/Yoosen/blog/edit/main/vuepress/interview/network.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/9/7 03:26:35</span></div><!----></footer><nav class="page-nav"><a href="/blog/interview/os.html" class="nav-link prev" arialabel="操作系统"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><i class="icon iconfont icon-caozuoxitong"></i>操作系统</div></a><!----></nav><!----><!----></main><!--]--><!----></div><!--]--><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.67ff9014.js" defer></script>
  </body>
</html>
